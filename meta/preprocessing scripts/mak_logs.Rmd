---
title: "Meta Logs"
author: "Kendra Wyant"
date: '`r format(Sys.time(), "%Y-%m-%d")`'
output: 
  html_document:
    toc: true 
    toc_depth: 4
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = dplyr::if_else(Sys.info()[["sysname"]] == "Windows",
      "P:/studydata/risk/knits/meta", 
      "/Volumes/private/studydata/risk/knits/meta")
    )
  })
---

### Notes
Purpose: This script does further cleaning and pre-processing on the voice and SMS 
logs specifically for meta study. It outputs a single clean log file joined with the 
cleaned contact variables ready for feature engineering in the meta project.    

Preprocessing steps:   

1. Handle any identified errors/anomalies in clean scripts    

2. Join logs on common variables    

3. Filter down to analysis sample (N = 154; participants who completed followup 1)    

4. Format numbers to match contacts and join with context variables   

5. EDA on numbers and check for contacts not in logs     

Inputs:  
- voice_ios.csv    
- voice_android.csv   
- sms_ios.csv   
- sms_android.csv  
- contacts.csv    

Output:   
- meta_logs.csv   

### Setup

```{css, echo = FALSE}
pre, code {
  max-height: 500px;
  overflow-y: auto;
  white-space: pre !important; 
  overflow-x: auto
}
```

Absolute Paths 
```{r}
switch (Sys.info()[['sysname']],
        # PC paths
        Windows = {
          path_shared <- "P:/studydata/risk/data_processed/shared"
          path_meta <- "P:/studydata/risk/data_processed/meta"
          # temporary directory to use check country code function not merged into production version
          path_lab_support <- "C:/Users/kpaquette2/lab_support"},
        # IOS paths
        Darwin = {
          path_shared <- "/Volumes/private/studydata/risk/data_processed/shared"
          path_meta <- "/Volumes/private/studydata/risk/data_processed/meta"
          # temporary directory to use check country code function not merged into production version
          path_lab_support <- "~/lab_support"})
```

Packages for lab workflow 
```{r, packages_workflow, message=FALSE, warning=FALSE}
# Detect and warn about function conflicts
library(conflicted) 
conflict_prefer("filter", "dplyr")

# establish project directory consistently as working directory
library(here)  
```

Packages and Source
```{r, message = FALSE}
library(tidyverse)
library(kableExtra)
library(readxl)
library(lubridate)
library(janitor)

source(file.path(path_lab_support, "fun_phone_numbers.R"))
```

Global Settings
```{r}
theme_set(theme_classic())
options(tibble.print_max = Inf)
options(tibble.width = Inf)
```


## Voice IOS logs

### Read in Data
Read in voice IOS data and filter down to variables for meta
```{r}
voice_ios <- vroom::vroom(file.path(path_shared, "voice_ios.csv"), col_types = cols()) %>%
  select(subid, zdate, zaddress, zduration, zanswered, zoriginated, zunique_id) %>% 
  glimpse()
```

### Clean errors identified in clean script EDA

Filter out log entries with missing dates
```{r}
voice_ios %>% 
  filter(is.na(zdate))

voice_ios <- voice_ios %>% 
  filter(!is.na(zdate))
```


FIX: invalid numbers with semicolon      
Look into why semicolon might exist?
```{r}
voice_ios %>% 
  filter(str_detect(zaddress, ";")) %>% 
  select(subid, zaddress)
```

Unclear what number after semicolon is. Keeping US number before semicolon as number.
```{r}
voice_ios <- voice_ios %>% 
  mutate(zaddress = case_when(zaddress == "608-663-3926;206" ~ "608-663-3926",
                              zaddress == "+12623678600;114" ~ "+12623678600",
                              zaddress == "6082561901;15045" ~ "6082561901",
                              zaddress == "+86566;n" ~ "+86566",
                              zaddress == "6082332100;2024" ~ "6082332100",
                              zaddress == "6086615437;116" ~ "6086615437",
                              zaddress == "8444176626;5618" ~ "8444176626",
                              zaddress == "18774155164;5077085016597013" ~ "18774155164",
                              TRUE ~ zaddress))
```



### Filter out duplicates

`r nrow(voice_ios) - nrow(distinct(voice_ios))` duplicates remain in dataset due to updates made to log entries between visits (e.g., read).   

Check all duplicates    
Duplicates vary on variable changed - doesn't matter for meta since we are not using the variables that were changed 
```{r}
voice_ios_full <- vroom::vroom(file.path(path_shared, "voice_ios.csv"), col_types = cols())

dup_voice_ios <- voice_ios %>% 
  count(across(subid:zunique_id)) %>% 
  filter(n > 1)

voice_ios_full %>% 
  left_join(dup_voice_ios, by = c("subid", "zdate", "zaddress", "zduration", "zanswered", "zoriginated", "zunique_id")) %>% 
  filter(!is.na(n)) %>% 
  arrange(subid, zdate) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("condensed", "striped")) %>% 
  scroll_box(width = "100%", height = "500px")
```


Remove duplicates
```{r}
voice_ios <- voice_ios %>% 
  distinct()
```



## Voice Android logs

### Read in data
```{r}
voice_android <- vroom::vroom(file.path(path_shared, "voice_android.csv"), col_types = cols()) %>% 
  select(subid, number, duration, date, type) %>% 
  glimpse()
```

### Clean errors identified in clean script EDA

FIX: invalid number with semicolon     
Look into why semicolon might exist?
```{r}
voice_android %>% 
  filter(str_detect(number, ";")) %>% 
  select(subid, number)
```
  
Unclear what number after semicolon is. Keeping US number before semicolon as number.
```{r}
voice_android <- voice_android %>% 
  mutate(number = case_when(number == "+1-385-262-3849;418173518#" ~ "3852623849",
                            TRUE ~ number))
```

Fix invalid duration value of -4   
Duration cannot be negative; changing to NA since no way of knowing actual duration
```{r}
voice_android <- voice_android %>% 
  mutate(duration = case_when(duration == -4 ~ as.numeric(NA),
                              TRUE ~ duration))
```

Fix invalid type values   
8 subids produced invalid numbers for type variable. Changing these numbers to NA since 
we have no way of determining correct value.
```{r}
voice_android <- voice_android %>% 
  mutate(type = case_when(type %in% c(8, 9, 10, 101, 1000, 1001, 1002, 6503) ~ as.character(NA),
                          TRUE ~ as.character(type)))
```

### Check duplicates   
No duplicates
```{r}
voice_android %>% 
  count(across(subid:type)) %>% 
  filter(n > 1)
```


<br>

## Join voice logs

### Common voice log variables relevant to meta project

- subid - participant identifier   
- date - date and time of log entry    
- number - raw phone number of other party   
- duration - duration of call    
- originated (incoming or outgoing)   
- answered   


### tidy android variables for merge
```{r}
voice_android %>% 
  glimpse()
```

Create new variables to match IOS
```{r}
voice_android <- voice_android %>% 
  rename(call_duration = duration) %>% 
  mutate(originated = case_when( type == "Missed" ~ "Incoming",
                                 type == "Voicemail" ~ "Incoming",
                                 type == "Rejected" ~ "Incoming",
                                 type == "Blocked" ~ "Incoming",
                                 type == "Answered Externally" ~ "Incoming",
                                 TRUE ~ type),
         call_answered = case_when(type == "Incoming" ~ "Answered",
                              is.na(type) ~ as.character(NA),
                              TRUE ~ "Not Answered")) %>% 
  select(-type) %>% 
  glimpse()
```


### tidy ios variables for merge
```{r}
voice_ios %>% 
  glimpse()

voice_ios <- voice_ios %>% 
  select(c(subid,
           date = zdate,
           call_answered = zanswered,
           originated = zoriginated,
           call_duration = zduration,
           number = zaddress)) %>%
  glimpse()
```


### Join
join voice logs
```{r}
logs_voice <- voice_android %>% 
  full_join(voice_ios,  by = c("subid", "number", "call_duration", "date", "originated", 
                               "call_answered")) %>% 
  # add new variable to mark these are voice logs
  mutate(log_type = "voice") %>% 
  glimpse()
```

<br>

## SMS IOS logs

### Read in data
```{r}
sms_ios <- vroom::vroom(file.path(path_shared, "sms_ios.csv"), col_types = cols()) %>%
  # temporarily keeping text to filter out duplicates
  select(subid, phone_number, date, is_delivered, is_from_me, is_sent, is_read, is_prepared, 
  text, chat_id) %>% 
  glimpse()
```

### Filter out duplicates

`r nrow(sms_ios) - nrow(distinct(sms_ios))` duplicates exist in dataset.  

Check all duplicates    
Duplicates appear to exist due to how group messages are handled. Same date, text, number but message_id, guid, other_handle, and other unique message identifiers seem to differ. These variables are not relevant for meta.      
```{r}
sms_ios_full <- vroom::vroom(file.path(path_shared, "sms_ios.csv"), col_types = cols())

dup_sms_ios <- sms_ios %>% 
  count(across(subid:chat_id)) %>% 
  filter(n > 1)

sms_ios_full %>% 
  left_join(dup_sms_ios, by = c("subid", "phone_number", "date", "is_delivered", 
                                  "is_from_me", "is_sent", "is_read", "is_prepared",
                                  "text", "chat_id")) %>% 
  filter(!is.na(n)) %>% 
  arrange(subid, date) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("condensed", "striped")) %>% 
  scroll_box(width = "100%", height = "500px")
```


Remove duplicates
```{r}
sms_ios <- sms_ios %>% 
  distinct()
```


### Group Messages

Identify group messages by more than one number associated with a subid/chat_id pair    

Outgoing text messages have NA as the number if sent to more than one person, if a direct message number is recipient of sent message.   

```{r}
ios_groups <- sms_ios %>% 
  filter(!is.na(chat_id)) %>% 
  group_by(subid, chat_id, phone_number) %>% 
  slice(1) %>% 
  group_by(subid, chat_id) %>% 
  summarise(n = n(), .groups = "drop") %>% 
  arrange(desc(n)) %>% 
  filter(n > 1)  

ios_groups %>%  
  print(n = Inf)
```


`r nrow(ios_groups)` group chats identified.    

Add a group variable
```{r}
ios_groups <- ios_groups %>%
  mutate(message_is_group = "yes")


sms_ios <- sms_ios %>% 
  left_join(ios_groups %>% select(-n), by = c("subid", "chat_id")) %>% 
  mutate(message_is_group = case_when(is.na(message_is_group) ~ "no",
                                      TRUE ~ message_is_group)) %>% 
  glimpse()
```

check new variable
```{r}
table(sms_ios$message_is_group)
```


FIX: Check all chat_ids with NA values for any signs of group messages (i.e., outgoing messages to NA)    
STILL NEED TO HANDLE
```{r}
sms_ios %>% 
  filter(is.na(chat_id))
```


<br>


## SMS Android logs

### Read in data
```{r}
sms_android <- vroom::vroom(file.path(path_shared, "sms_android.csv"), col_types = cols()) %>% 
  # keep text message content in for filtering out duplicates
  select(subid, address, date, type, text = body, read) %>% 
  glimpse()
```

### Filter out Duplicates    

`r nrow(sms_android) - nrow(distinct(sms_android))` duplicates exist in dataset.  

Check all duplicates    
```{r}
sms_android_full <- vroom::vroom(file.path(path_shared, "sms_android.csv"), col_types = cols()) %>% 
  rename(text = body)

dup_sms_android <- sms_android %>% 
  count(across(subid:read)) %>% 
  filter(n > 1)

sms_android_full %>% 
  left_join(dup_sms_android, by = c("subid", "address", "date", "type", "text", "read")) %>% 
  filter(!is.na(n)) %>% 
  arrange(subid, date) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("condensed", "striped")) %>% 
  scroll_box(width = "100%", height = "500px")
```


Remove duplicates
```{r}
sms_android <- sms_android %>% 
  distinct()
```


### Group Messages

Identify group messages 
```{r}
sms_android %>% 
  filter(str_detect(address, "~")) %>% 
  select(address)

# Note that type is NA for group messages
sms_android %>% 
  filter(str_detect(address, "~")) %>% 
  tabyl(type)
```

Add group variable
```{r}
sms_android <- sms_android %>% 
  mutate(message_is_group = case_when(str_detect(address, "~") ~ "yes", 
                                      TRUE ~ "no")) %>% 
  glimpse()

tabyl(sms_android$message_is_group)
```

Change numbers to NA (to be consistent with IOS)
```{r}
sms_android <- sms_android %>% 
  mutate(address = case_when(str_detect(address, "~") ~ as.character(NA), 
                                      TRUE ~ address))
```


<br>

## Join SMS variables

### Common voice log variables relevant to meta project  

read = yes if sent or read status on incoming message  
failed = yes if outgoing message not delivered    
originated = outgoing if from_me else incoming (type is NA for android group messages)    
group_message = yes if group message   


### tidy android variables for merge
```{r}
sms_android <- sms_android %>% 
  rename(number = address,
         message_read = read) %>% 
  mutate(message_failed = if_else(type == "failed", "yes", "no"),
         originated = case_when(type == "sent" ~ "outgoing",
                                  type == "draft" ~ "outgoing",
                                  type == "failed" ~ "outgoing",
                                  type == "inbox" ~ "incoming")) %>% 
  select(-c(text, type)) %>% 
  glimpse()
```


### tidy IOS variables for merge

```{r}
sms_ios <- sms_ios %>% 
  rename(number = phone_number) %>% 
  mutate(message_read = case_when(is_read == 1 ~ "yes",
                               is_from_me == 1 ~ "yes",
                               TRUE ~ "no"),
         message_failed = if_else(is_sent == 0, "yes", "no"),
         originated = case_when(is_sent == 1 ~ "outgoing",
                                  is_from_me == 1 ~ "outgoing",
                                  TRUE ~ "incoming")) %>% 
  select(-c(is_delivered, is_from_me, is_sent, is_read, is_prepared, chat_id, text)) %>% 
  glimpse()
```


### Join

FIX: Will need to check all these new variables with extensive EDA to make sure they are accurate  

```{r}
logs_sms <- sms_android %>%
  full_join(sms_ios, by = c("subid", "number", "date", "message_read", "message_failed", 
                            "originated", "message_is_group")) %>%
  # add new variable to mark these are sms logs
  mutate(log_type = "sms") %>%
  glimpse()
```

<br>

## Join SMS and Voice logs

```{r}
logs <- logs_voice %>%
  full_join(logs_sms, by = c("subid", "date", "number", "log_type", "originated")) %>%
  select(subid, date, number, log_type, originated, everything()) %>% 
  mutate(subid = as.numeric(subid)) %>% 
  glimpse()
```

<br> 

Filter down to analysis sample (N = 154)   

Read in visit dates
```{r}
visit_dates <- read_csv(file.path(path_shared, "visit_dates.csv"), col_types = cols()) 

study_sample <- visit_dates %>% 
  filter(!is.na(followup_1)) %>% 
  glimpse()
```

Filter log data
```{r}
logs <- logs %>% 
  filter(subid %in% study_sample$subid)
```


<br>

## Contacts

### Read in Data
```{r}
contacts <- read_csv(file.path(path_shared, "contacts.csv"), col_types = "icccccccccccccc") %>% 
  glimpse()
```

Filter contacts down to analysis sample
```{r}
contacts <- contacts %>% 
  filter(subid %in% study_sample$subid)
```

### Clean errors identified in clean script EDA

Invalid response (unpleasant/mixed) for "How would you describe your typical experience 
with this person?"   

Recode as mixed  
```{r}
contacts <- contacts %>% 
  mutate(contact_experience = case_when(contact_experience == "Unpleasant/mixed" ~ "Mixed",
                                        TRUE ~ contact_experience))
```

Remove entry with missing number
```{r}
contacts %>% 
  filter(is.na(phone_number))

contacts <- contacts %>% 
  filter(!is.na(phone_number))
```

### Handle duplicate numbers 
```{r}
# Duplicate subid/phone number pairs
dup_contacts <- contacts %>%
  group_by(subid, phone_number) %>%
  summarise(n = n(), .groups = "drop") %>%
  dplyr::filter(n > 1)

print(dup_contacts, n = Inf)
```

`r nrow(dup_contacts)` duplicates to handle    
```{r}
dup_contacts <- contacts %>%
  left_join(dup_contacts, by = c("subid", "phone_number")) %>%
  arrange(subid, phone_number) %>% 
  filter(n == 2) 
```

<br>

Duplicate 1: Subid 33   
Differs only on contact type - keep first entry   
```{r}
dup_contacts %>%
  slice(1:2)

contacts <- contacts %>% 
  filter(!(subid == 33 & utc == 1519146600 & phone_number == 6088735039))
```

Duplicate 2: Subid 86
Differs on two context variable and address   
Keep first entry but with updated address
```{r}
dup_contacts %>%
  slice(3:4)

contacts <- contacts %>% 
  mutate(street_address = case_when(subid == 86 & utc == "1531924200" & phone_number == "6304275562" ~ 
                                      "642 State Street",
                                    TRUE ~ street_address),
         city = case_when(subid == 86 & utc == "1531924200" & phone_number == "6304275562" ~ 
                                      "Madison",
                                    TRUE ~ city),
         state = case_when(subid == 86 & utc == "1531924200" & phone_number == "6304275562" ~ 
                                      "WI",
                                    TRUE ~ state)) %>% 
  filter(!(subid == 86 & utc == 1534779600 & phone_number == 6304275562))
```

Duplicate 3: Subid 97  
Differs only on contact type
Keep first entry 
```{r}
dup_contacts %>%
  slice(5:6)

contacts <- contacts %>% 
  filter(!(subid == 97 & utc == 1537889400 & phone_number == 6086433393))
```

Duplicate 4: Subid 104  
This is an interesting one because it looks like they stopped frequently visiting a family member (monthly visit variable).   
Keep first entry
```{r}
dup_contacts %>%
  slice(7:8)

contacts <- contacts %>% 
  filter(!(subid == 104 & utc == 1537991280 & phone_number == 6084693159))
```

Duplicate 5: Subid 109  
Keep first entry 
```{r}
dup_contacts %>%
  slice(9:10)

contacts <- contacts %>% 
  filter(!(subid == 109 & utc == 1542036600 & phone_number == 6305611375))
```

Duplicate 6: Subid 110  
Keep 2nd entry - Both entries completed on same day.   
FIX: try to find subids cell phone number
```{r}
dup_contacts %>%
  slice(11:12)

contacts <- contacts %>% 
  filter(!(subid == 110 & utc == 1534531200 & phone_number == 4148819604))
```

Duplicate 7-8: Subid 117   
These 2 are really conflicting - removing context entries since we can discern which is correct
```{r}
dup_contacts %>%
  slice(13:14)

dup_contacts %>%
  slice(15:16)

contacts <- contacts %>% 
  filter(!(subid == 117 & phone_number == 6085987543)) %>% 
  filter(!(subid == 117 & phone_number == 919811021816))
```

Duplicate 9: Subid 119  
Keep 2nd entry with context variables
```{r}
dup_contacts %>%
  slice(17:18)

contacts <- contacts %>% 
  filter(!(subid == 119 & utc == 1540397820 & phone_number == 6082398865))
```

Duplicate 10: Subid 139   
Keep first entry
```{r}
dup_contacts %>%
  slice(19:20)

contacts <- contacts %>% 
  filter(!(subid == 139 & utc == 1548171000 & phone_number == 6082137652))
```

Duplicate 11: Subid 143   
Keep 1st entry
```{r}
dup_contacts %>%
  slice(21:22)

contacts <- contacts %>% 
  filter(!(subid == 143 & utc == 1541790000 & phone_number == 6082828270))
```

Duplicate 12: Subid 240   
Only change is updated address   
Keep first entry since this was address 2/3 months on study   
```{r}
dup_contacts %>%
  slice(23:24)

contacts <- contacts %>% 
  filter(!(subid == 240 & utc == 1566831600 & phone_number == 9204509643))
```

Duplicate 13-16: Subid 248  
13 differs on only one variable - keep 1st entry  
```{r}
dup_contacts %>%
  slice(25:26)

contacts <- contacts %>% 
  filter(!(subid == 248 & utc == 1568314800 & phone_number == 6084452342))
```

14 differs on three variables some are probably important (drinker vs. nondrinker)   
Keep first entry 
```{r}
dup_contacts %>%
  slice(27:28)

contacts <- contacts %>% 
  filter(!(subid == 248 & utc == 1568314800 & phone_number == 6086695757))
```

15 differs on only one variable - keep 1st entry  
```{r}
dup_contacts %>%
  slice(29:30)

contacts <- contacts %>% 
  filter(!(subid == 248 & utc == 1568314800 & phone_number == 6088432572))
```

16 differs on 3 variables   
Keep first entry
```{r}
dup_contacts %>%
  slice(31:32)

contacts <- contacts %>% 
  filter(!(subid == 248 & utc == 1568314800 & phone_number == 9062815847))
```

Duplicate 17-18: Subid 269   
Keep first entry
```{r}
dup_contacts %>%
  slice(33:34)

contacts <- contacts %>% 
  filter(!(subid == 269 & utc = 1573150500 & phone_number == 6083473760))
```

Keep 1st entry
```{r}
dup_contacts %>%
  slice(35:36)

contacts <- contacts %>% 
  filter(!(subid == 269 & utc == 1575567600 & phone_number == 6309131339))
```




<br>


## Clean numbers

Clean numbers with function
```{r}
# logs$number_formatted <- map_chr(logs$number, extract_number, print_warning = FALSE)
```

<br>

### Pull area codes for 7 digit numbers from contacts
```{r message = FALSE}
numbers_7_digits <- logs %>% 
  filter(str_detect(number, "^[1-9]") & nchar(number) == 7) %>% 
  select(number) %>% 
  unlist(use.names = FALSE)

contacts_7_digits <- tibble(subid = as.numeric())

for (i in seq_along(numbers_7_digits)) {
  match <- contacts %>% 
    filter(str_detect(phone_number, numbers_7_digits[i])) %>% 
    mutate(pattern = numbers_7_digits[i])
  if(nrow(match) != 0) {  
    contacts_7_digits <- contacts_7_digits %>% full_join(match)
  }
}

contacts_7_digits %>% 
  select(subid, phone_number, pattern, contact_type) %>% 
  group_by(subid, phone_number, pattern) %>% 
  slice(1) %>% 
  print(n = Inf) 
```

Area code is 608 for most but not all 7-digit number matches
```{r}
contacts_7_digits %>% 
  mutate(area_code = str_sub(phone_number, 1, 3)) %>% 
  tabyl(area_code)
```

Join numbers with log entries on number and subid and replace formatted number with contact number
```{r}
logs <- logs %>% 
  mutate(subid = as.numeric(subid)) %>% 
  left_join(contacts_7_digits %>% 
              select(subid, contact_number = phone_number, number = pattern), 
            by = c("subid", "number")) %>% 
  mutate(number_formatted = case_when(!is.na(contact_number) ~ as.character(contact_number),
                                      # FIX: change number to number_formatted when using extract number function
                                      TRUE ~ number)) %>% 
  glimpse()
```

Log entries with contact matches
```{r}
logs %>% 
  filter(!is.na(contact_number)) %>% 
  select(subid, number, contact_number, date) %>% 
  print(n = Inf)
```

remove contact number variable
```{r}
logs <- logs %>% 
  select(-contact_number)
```

<br>

## Join logs with contacts on formatted number
```{r}
glimpse(contacts)
glimpse(logs)

logs <- logs %>% 
  left_join(contacts %>% 
              select(-utc) %>% 
              mutate(phone_number = as.character(phone_number)), 
              by = c("subid", "number_formatted" = "phone_number")) %>% 
  glimpse()
```

<br>

## Contacts without log entries

FIX: Check contacts without log entries in case of typos in contacts file    
Still need to handle
```{r}

```

<br>

## Check unknown patterns for matches to contacts   

FIX: print warnings and look for matches to contacts   
Still need to handle

<br>

## Other EDA

Missing data   
FIX: Remove street address, city, and state?
```{r}
logs %>%
  naniar::miss_var_summary()
```


EDA on call and text message variables

FIX: Still need to handle
```{r}

```

<br>


## Write csv
```{r}
write_csv(logs, file.path(path_meta, "meta_logs.csv")) %>% 
  glimpse()
```

<br>










