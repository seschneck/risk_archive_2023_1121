---
title: "Meta Logs"
author: "Kendra Wyant"
date: '`r format(Sys.time(), "%Y-%m-%d")`'
output: 
  html_document:
    toc: true 
    toc_depth: 4
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = dplyr::if_else(Sys.info()[["sysname"]] == "Windows",
      "P:/studydata/risk/knits/meta", 
      "/Volumes/private/studydata/risk/knits/meta")
    )
  })
---

### Notes
Purpose: This script does further cleaning and pre-processing on the voice and SMS 
logs specifically for meta study. It outputs a single clean log file joined with the 
cleaned contact variables ready for feature engineering in the meta project.    

Preprocessing steps:   

1. Handle any identified errors/anomalies in clean scripts    

2. Join logs on common variables    

3. Filter down to analysis sample (N = 154; participants who completed followup 1)    

4. Format numbers to match contacts and join with context variables   

5. EDA on numbers and check for contacts not in logs     

Inputs:  
- voice_ios.csv    
- voice_android.csv   
- sms_ios.csv   
- sms_android.csv  
- contacts.csv    

Output:   
- meta_logs.csv   

### Setup

```{css, echo = FALSE}
pre, code {
  max-height: 500px;
  overflow-y: auto;
  white-space: pre !important; 
  overflow-x: auto
}
```

Absolute Paths 
```{r}
switch (Sys.info()[['sysname']],
        # PC paths
        Windows = {
          path_shared <- "P:/studydata/risk/data_processed/shared"
          path_meta <- "P:/studydata/risk/data_processed/meta"
          # temporary directory to use check country code function not merged into production version
          path_lab_support <- "C:/Users/kpaquette2/lab_support"},
        # IOS paths
        Darwin = {
          path_shared <- "/Volumes/private/studydata/risk/data_processed/shared"
          path_meta <- "/Volumes/private/studydata/risk/data_processed/meta"
          # temporary directory to use check country code function not merged into production version
          path_lab_support <- "~/lab_support"})
```

Packages for lab workflow 
```{r, packages_workflow, message=FALSE, warning=FALSE}
# Detect and warn about function conflicts
library(conflicted) 
conflict_prefer("filter", "dplyr")

# establish project directory consistently as working directory
library(here)  
```

Packages and Source
```{r, message = FALSE}
library(tidyverse)
library(kableExtra)
library(readxl)
library(lubridate)
library(janitor)

source(file.path(path_lab_support, "fun_phone_numbers.R"))
```

Global Settings
```{r}
theme_set(theme_classic())
options(tibble.print_max = Inf)
options(tibble.width = Inf)
```


## Voice IOS logs

### Read in Data
Read in voice IOS data and filter down to variables for meta
```{r}
voice_ios <- vroom::vroom(file.path(path_shared, "voice_ios.csv"), col_types = cols()) %>% 
  select(subid, zdate, zaddress, zduration, zanswered, zoriginated, zcalltype, zunique_id) %>% 
  glimpse()
```

### Clean errors identified in clean script EDA

Filter out log entries with missing dates
```{r}
voice_ios %>% 
  filter(is.na(zdate))

voice_ios <- voice_ios %>% 
  filter(!is.na(zdate))
```


FIX: invalid numbers with semicolon     
```{r}
voice_ios %>% 
  filter(str_detect(zaddress, ";")) %>% 
  select(subid, zaddress)
```

Unclear what number after semicolon is. Keeping US number before semicolon as number.
```{r}
voice_ios <- voice_ios %>% 
  mutate(zaddress = case_when(zaddress == "608-663-3926;206" ~ "608-663-3926",
                              zaddress == "+12623678600;114" ~ "+12623678600",
                              zaddress == "6082561901;15045" ~ "6082561901",
                              zaddress == "+86566;n" ~ "+86566",
                              zaddress == "6082332100;2024" ~ "6082332100",
                              zaddress == "6086615437;116" ~ "6086615437",
                              zaddress == "8444176626;5618" ~ "8444176626",
                              zaddress == "18774155164;5077085016597013" ~ "18774155164",
                              TRUE ~ zaddress))
```



### Filter out duplicates

`r nrow(voice_ios) - nrow(distinct(voice_ios))` duplicates remain in dataset due to changes in read status. Not using this variable in meta so these are identical observations.     

Remove duplicates

```{r}
voice_ios <- voice_ios %>% 
  distinct() %>% 
  glimpse()
```


## Voice Android logs

### Read in data
```{r}
voice_android <- vroom::vroom(file.path(path_shared, "voice_android.csv"), col_types = cols()) %>% 
  select(subid, number, duration, date, type, presentation) %>% 
  glimpse()
```

### Clean errors identified in clean script EDA

FIX: invalid number with semicolon     
```{r}
voice_android %>% 
  filter(str_detect(number, ";")) %>% 
  select(subid, number)
```
  
Unclear what number after semicolon is. Keeping US number before semicolon as number.
```{r}
voice_android <- voice_android %>% 
  mutate(number = case_when(number == "+1-385-262-3849;418173518#" ~ "3852623849",
                            TRUE ~ number))
```

FIX: invalid duration value of -4   
Duration cannot be negative; changing to NA since no way of knowing actual duration
```{r}
voice_android <- voice_android %>% 
  mutate(duration = case_when(duration == -4 ~ as.numeric(NA),
                              TRUE ~ duration))
```

FIX: invalid type values   
8 subids produced invalid numbers for type variable. Changing these numbers to NA since 
we have no way of determining correct value.
```{r}
voice_android <- voice_android %>% 
  mutate(type = case_when(type %in% c(8, 9, 10, 101, 1000, 1001, 1002, 6503) ~ as.character(NA),
                          TRUE ~ as.character(type)))
```




## SMS IOS logs

### Read in data
```{r}

```

### Filter out duplicate GUIDs

### Clean errors identified in clean script EDA

FIX: Label #'s for group messages as group (default is NA)
```{r}

```


## SMS Android logs

### Read in data
```{r}

```

### Clean errors identified in clean script EDA

FIX: Label #'s for group messages as group (default is many numbers separated by ~)
```{r}

```


## Contacts

### Read in Data
```{r}
contacts <- read_csv(file.path(path_shared, "contacts.csv"), col_types = "icccccccccccccc") %>% 
  glimpse()
```

### Clean errors identified in clean script EDA

FIX: Invalid unpleasant/mixed response for "How would you describe your typical experience 
with this person?"   
Recode as mixed  
```{r}
contacts <- contacts %>% 
  mutate(contact_experience = case_when(contact_experience == "Unpleasant/mixed" ~ "Mixed",
                                        TRUE ~ contact_experience))
```

FIX: Remove entry with missing number
```{r}
contacts %>% 
  filter(is.na(phone_number))

contacts <- contacts %>% 
  filter(!is.na(phone_number))
```

FIX: Duplicate entries for numbers
```{r}
# Duplicate subid/phone number pairs
duplicates <- contacts %>%
  group_by(subid, phone_number) %>%
  summarise(n = n(), .groups = "drop") %>%
  dplyr::filter(n > 1)

print(duplicates, n = Inf)
```

`r nrow(duplicates)` duplicates to handle  

Duplicate 1: Subid 24  
Differs only on one context variable - may be two different parents but no way to know 
which they are speaking to.    
JOHN: Change contact_drink_future to NA?  
UPDATE: This subid does not make it to followup 1 so these entries will be filtered out.
```{r}
duplicates <- contacts %>%
  dplyr::filter(phone_number %in% duplicates$phone_number & subid %in% duplicates$subid) %>%
  arrange(subid, phone_number) 

duplicates %>%
  slice(1:2)
```

Duplicate 2: Subid 33   
Differs only on contact type - keep first entry
```{r}
duplicates %>%
  slice(3:4)

contacts <- contacts %>% 
  filter(!(subid == 33 & utc == 1519146600 & phone_number == 6088735039))
```

Duplicate 3: Subid 86
Differs on two context variable and address   
JOHN: Keep first entry but with updated address? We probably don't need address for this 
study or maybe just state for feature engineering (out of state calls).
```{r}
duplicates %>%
  slice(5:6)
```

Duplicate 4: Subid 97  
Keep first entry - Although Other Phone might be a more accurate phone_type description
```{r}
duplicates %>%
  slice(7:8)

contacts <- contacts %>% 
  filter(!(subid == 97 & utc == 1537889400 & phone_number == 6086433393))
```

Duplicate 5: Subid 104  
Differs on one context variable and updates address  
JOHN: Keep first entry with address added to it?
```{r}
duplicates %>%
  slice(9:10)
```

Duplicate 6: Subid 109  
Keep first entry
```{r}
duplicates %>%
  slice(11:12)

contacts <- contacts %>% 
  filter(!(subid == 109 & utc == 1542036600 & phone_number == 6305611375))
```

Duplicate 7: Subid 110  
JOHN: Keep 2nd entry?
```{r}
duplicates %>%
  slice(13:14)
```

Duplicate 8-9: Subid 117   
JOHN: These 2 are really conflicting - not sure how to handle
```{r}
duplicates %>%
  slice(15:16)

duplicates %>%
  slice(17:18)
```

Duplicate 10: Subid 119
```{r}
duplicates %>%
  slice(19:20)
```

Duplicate 11: Subid 139   
Keep 2nd entry
```{r}
duplicates %>%
  slice(21:22)

contacts <- contacts %>% 
  filter(!(subid == 119 & utc == 1540397820 & phone_number == 6082398865))
```

Duplicate 12: Subid 143   
Keep 1st entry
```{r}
duplicates %>%
  slice(23:24)

contacts <- contacts %>% 
  filter(!(subid == 143 & utc == 1541790000 & phone_number == 6082828270))
```

Duplicate 13: Subid 240   
Only change is updated address - Keep 2nd entry 
```{r}
duplicates %>%
  slice(25:26)

contacts <- contacts %>% 
  filter(!(subid == 240 & utc == 1561474800 & phone_number == 9204509643))
```

Duplicate 14-17: Subid 248  
14 differs on only one variable - keep 1st entry  
```{r}
duplicates %>%
  slice(27:28)

contacts <- contacts %>% 
  filter(!(subid == 248 & utc == 1568314800 & phone_number == 6084452342))
```

15 differs on three variables some are probably important (drinker vs. nondrinker)   
JOHN: How to handle?
```{r}
duplicates %>%
  slice(29:30)
```

16 differs on only one variable - keep 1st entry  
```{r}
duplicates %>%
  slice(31:32)

contacts <- contacts %>% 
  filter(!(subid == 248 & utc == 1568314800 & phone_number == 6088432572))
```

17 differs on 3 variables   
JOHN: How to handle?
```{r}
duplicates %>%
  slice(33:34)
```

Duplicate 18-19: Subid 269   
These differ quite a bit - makes me wonder how much we can trust either entry.  
JOHN: How to handle?
```{r}
duplicates %>%
  slice(35:36)

duplicates %>%
  slice(37:38)
```



## Join voice logs

### Common voice log variables relevant to meta project

- subid - participant identifier   
- date - date and time of log entry    
- number - raw phone number of other party  
- duration - duration of call    
- presentation - whether number was available, or blocked/unknown    
- originated (incoming or outgoing)  
- answered  
- call_type - phone, facetime audio, facetime video


### tidy android variables for merge
```{r}
voice_android %>% 
  glimpse()
```

Create new variables to match IOS
```{r}
voice_android <- voice_android %>% 
  mutate(originated = case_when( type == "Missed" ~ "Incoming",
                                 type == "Voicemail" ~ "Incoming",
                                 type == "Rejected" ~ "Incoming",
                                 type == "Blocked" ~ "Incoming",
                                 type == "Answered Externally" ~ "Incoming",
                                 TRUE ~ type),
         answered = case_when(type == "Incoming" ~ "Answered",
                              is.na(type) ~ as.character(NA),
                              TRUE ~ "Not Answered"),
         call_type = "Phone") %>% 
  glimpse()
```


### tidy ios variables for merge
```{r}
voice_ios %>% 
  glimpse()

voice_ios <- voice_ios %>% 
  select(c(subid,
           date = zdate,
           answered = zanswered,
           originated = zoriginated,
           call_type = zcalltype,
           duration = zduration,
           number = zaddress)) %>% 
  glimpse()
```


### Join
join voice logs
```{r}
logs_voice <- voice_android %>% 
  full_join(voice_ios,  by = c("subid", "number", "duration", "date", "originated", 
                               "answered", "call_type")) %>% 
  # add new variable to mark these are voice logs
  mutate(log_type = "voice") %>% 
  glimpse()
```

<br>


## Join SMS variables

### Common voice log variables relevant to meta project

### tidy android variables for merge

### tidy IOS variables for merge

### Join
```{r}
# logs_sms <- sms_android %>% 
#   full_join(sms_ios, by = c()) %>% 
#   # add new variable to mark these are sms logs
#   mutate(log_type = "sms") %>% 
#   glimpse()
# 
# join SMS and voice logs
logs <- logs_voice 
# %>% 
#   full_join(logs_sms, by = c()) %>% 
#   glimpse()
```



## Filter down to analysis sample (N = 154)
Read in visit dates
```{r}
visit_dates <- read_csv(file.path(path_shared, "visit_dates.csv"), col_types = cols())

study_sample <- visit_dates %>% 
  filter(!is.na(followup_1)) %>% 
  glimpse()
```

Filter log data
```{r}
logs <- logs %>% 
  filter(subid %in% study_sample$subid)
```

Filter contacts 
```{r}
contacts <- contacts %>% 
  filter(subid %in% study_sample$subid)
```


## Clean numbers

Clean numbers with function
```{r}
logs$number_formatted <- map_chr(logs$number, extract_number, print_warning = TRUE)
```

### Check unknown patterns for matches to contacts   



### Pull area codes for 7 digit numbers from contacts
```{r message = FALSE}
numbers_7_digits <- logs %>% 
  filter(str_detect(number, "^[1-9]") & nchar(number) == 7) %>% 
  select(number) %>% 
  unlist(use.names = FALSE)

contacts_7_digits <- tibble(subid = as.numeric())

for (i in seq_along(numbers_7_digits)) {
  match <- contacts %>% 
    filter(str_detect(phone_number, numbers_7_digits[i])) %>% 
    mutate(pattern = numbers_7_digits[i])
  if(nrow(match) != 0) {  
    contacts_7_digits <- contacts_7_digits %>% full_join(match)
  }
}

contacts_7_digits %>% 
  select(subid, phone_number, pattern, contact_type) %>% 
  group_by(subid, phone_number, pattern) %>% 
  slice(1) %>% 
  print(n = Inf) 
```

Area code is 608 for most but not all 7-digit number matches
```{r}
contacts_7_digits %>% 
  mutate(area_code = str_sub(phone_number, 1, 3)) %>% 
  tabyl(area_code)
```

Join numbers with log entries on number and subid and replace formatted number with contact number
```{r}
logs <- logs %>% 
  left_join(contacts_7_digits %>% 
              select(subid, contact_number = phone_number, number = pattern), 
            by = c("subid", "number")) %>% 
  mutate(number_formatted = case_when(!is.na(contact_number) ~ as.character(contact_number),
                                      TRUE ~ number_formatted)) %>% 
  glimpse()
```

Log entries with contact matches
```{r}
logs %>% 
  filter(!is.na(contact_number)) %>% 
  select(subid, number, contact_number, date) %>% 
  print(n = Inf)
```

remove contact number variable
```{r}
logs <- logs %>% 
  select(-contact_number)
```

Contact numbers more than 10 digits in length        
```{r}
contacts %>% 
  filter(nchar(phone_number) > 10) %>% 
  select(subid, phone_number, contact_type)
```
91 - India  
57 - Columbia   
800050001020 is health insurance scammer according to Google  


## Join logs with contacts on formatted number
```{r}
glimpse(contacts)

logs <- logs %>% 
  left_join(contacts %>% 
              select(-utc) %>% 
              mutate(phone_number = as.character(phone_number)), 
              by = c("subid", "number_formatted" = "phone_number")) %>% 
  glimpse()
```


## Contacts without log entries


## EDA

Missing data
```{r}
logs %>%
  naniar::miss_var_summary()
```

FIX: Remove street address, city, and state?


contact name doesn't seem to be related to context variables/known contacts
```{r}
logs %>% 
  filter(is.na(contact_name)) %>% 
  tabyl(contact_type)

logs %>% 
  filter(!is.na(contact_name)) %>% 
  tabyl(contact_type)
```




## Write csv
```{r}
write_csv(logs, file.path(path_meta, "meta_logs.csv")) %>% 
  glimpse()
```

<br>










