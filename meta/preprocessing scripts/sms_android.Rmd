---
title: "Andriod/SMS Logs"
author: "Kendra Wyant"
date: '`r format(Sys.time(), "%Y-%m-%d")`'
output: 
  html_document:
    toc: true 
    toc_depth: 2
editor_options: 
  chunk_output_type: console
---

### Notes
Purpose: This script does further cleaning and pre-processing on the android SMS logs specifically for meta study.   
All variables I defined through EDA and online resources. I found this summary of variables at the end which confirmed what I had concluded https://synctech.com.au/sms-backup-restore/fields-in-xml-backup-files/   

Inputs:  
- sms_android.csv (path_in)    

Output:   
- meta_sms_android.csv (path_out)  



### Setup
```{css, echo = FALSE}
pre, code {
  max-height: 500px;
  overflow-y: auto;
  white-space: pre !important; 
  overflow-x: auto
}
```


Paths 
```{r}
path_in <- "Z:/studydata/risk/analysis/shared/data"
path_out <- "Z:/studydata/risk/analysis/meta/data"
```

Packages and Source
```{r, message = FALSE}
library(tidyverse)
library(kableExtra)
library(lubridate)

source("C:/Users/kpaquette2/lab_support/fun_phone_numbers.R")
```

### Read in logs
```{r}
logs <- read_csv(file.path(path_in, "sms_android.csv"), col_types = cols()) %>% 
  glimpse()
```

Not sure why subids are read in as character   
All are numeric
```{r}
logs %>% 
  group_by(subid) %>% 
  slice(1) %>% 
  select(subid) %>% 
  print(n = Inf)
```

Convert to numeric
```{r}
logs <- logs %>% 
  mutate(subid = as.numeric(subid)) %>% 
  glimpse()
```


### Errors identified in clean script EDA

One date was parsed or read incorrectly - should be in 13 digit UTC but was -1 in raw log file.
```{r}
logs %>% 
  arrange(date)
```

Place in log shows that this message likely occurred in July which is prior to the subids start date of 9/08 - will be filtered out.
```{r}
logs %>% 
  filter(log_file == "128_SMS_1.xml") %>% 
  arrange(date) 
```

Changing date to NA for now since current date is not accurate  
```{r}
logs <- logs %>% 
  mutate(date = case_when(subid == 128 & address == "+16087127555" & date(date) == "1970-01-01" ~ as_datetime(NA),
         TRUE ~ date))
```

Cannot use log entry without date so checking for other missing date values   
No other missing dates
```{r}
logs %>% 
  filter(is.na(date))
```

filter out the 1 log entry with no date
```{r}
logs <- logs %>% 
  filter(!is.na(date))
```



### EDA and pre-processing

#### Missing data
```{r}
logs %>% 
  naniar::miss_var_summary()
```

100% of texts missing message (note text message content is in body variable)     
Remove message variable
```{r}
logs <- logs %>% 
  select(-message) %>% 
  glimpse()
```


#### Date (date message was received)
Dates range from `r min(logs$date, na.rm = TRUE)` to `r max(logs$date, na.rm = TRUE)`    

#### Type
Type of message - valid options are 1 - 5
```{r}
logs %>% 
  janitor::tabyl(type)
```

* 1 = inbox  
* 2 = sent  
* 3 = draft  
* 4 = temporary state of outbox (ultimately ends up in sent or failed)   
* 5 = failed

Type 19's all belong to one subid and contain alerts (should be incoming/type 1?)
```{r}
logs %>% 
  filter(type == 19) %>% 
  select(subid, address, body)
```

Check type for other alerts
```{r}
logs %>% 
  filter(str_detect(address, "alert") | str_detect(address, "Alert") | str_detect(address, "Amber")) %>% 
  select(address, contact_name, type) %>% 
  print(n = Inf)
```

Change type for incoming alerts to 1
```{r}
logs <- logs %>% 
  mutate(type = case_when(type == 19 ~ 1,
                          TRUE ~ type))
```


Type -1 may signify an outgoing message to a group of people  
https://www.ijser.org/researchpaper/Identification-of-Fake-SMS-generated-using-Android-Applications-in-Android-Devices.pdf
```{r}
logs %>% 
  filter(type == -1) %>% 
  count(contact_name) %>% 
  print(n = Inf)
```

Check for other group messages    
All group messages are type -1 or NA
```{r}
logs %>% 
  filter(str_detect(address, "~")) %>% 
  count(type)
```

Type -1 responses all belong to 6 subids. Their type of Android may be creating variables not consistent with other subids.
```{r}
logs %>% 
  filter(!type %in% c(1:5, NA)) %>% 
  count(subid)
```

However 37 subids have group messages
```{r}
logs %>% 
  filter(str_detect(address, "~")) %>% 
  count(subid)
```

Due to inconsistent coding will recode type -1 as NA and use address column to identify group messages
```{r}
logs <- logs %>%
  mutate(type = case_when(type == -1 ~ as.numeric(NA),
                          TRUE ~ type))

logs %>%
  janitor::tabyl(type)
```


Type 3 is drafts - may not want to include in model
```{r}
logs %>% 
  filter(type == 3)
```


#### Status
TP-Status value for the message (TP = transfer protocol)
```{r}
logs %>% 
  janitor::tabyl(status)
```

* -1 = no status  
* 0 = status complete  
* 32 = status pending   
* 64 = status failed   

All failed calls (status = 64) also show type as failed (type = 5)
```{r}
logs %>% 
  filter(status == 64) %>% 
  count(type)
```

Some failed calls with type = 5 have no status (-1)   
*Type might be more informative if interested in failed calls*
```{r}
logs %>% 
  filter(type == 5) %>% 
  count(status)
```


#### Read
Boolean value for "Has the message been read"?
```{r}
logs %>% 
  janitor::tabyl(read)
```

* 0 = no   
* 1 = yes  

All unread messages are incoming or type unknown   
```{r}
logs %>% 
  filter(read == 0) %>% 
  count(type)
```


#### Locked
Boolean value for "Is the message locked"?   
Locking a text message marks the message to prevent it from being deleted.
```{r}
logs %>% 
  janitor::tabyl(locked)
```

15 subids have locked messages
```{r}
logs %>% 
  filter(locked == 1) %>% 
  count(subid) %>% 
  arrange(desc(n))
```


#### Protocol
Protocol identifier code - 0 is default value for SMS (short message service)       
All but 17 entries are 0 or NA
```{r}
logs %>% 
  janitor::tabyl(protocol)
```

All 57 cases belong to subid 117 and all 95 cases belong to subid 191
```{r}
logs %>% 
  filter(protocol == 57 | protocol == 95)
```

Since there doesn't seem to be much info in this variable, I am removing it
```{r}
logs <- logs %>%
  select(-protocol) %>%
  glimpse()
```


#### Subject
Subject of text message should always be null in SMS
```{r}
logs %>% 
  count(subject == "null")

logs %>% 
  filter(subject != "null") %>% 
  select(subject) %>% 
  print(n = Inf)
```

All non-null subjects belong to one subid
```{r}
logs %>% 
  filter(subject != "null") %>% 
  count(subid)
```

Not clear why there is a subject on these messages
```{r}
logs %>% 
  filter(subject != "null") %>% 
  select(address, contact_name, body)
```

Removing subject variable 
```{r}
logs <- logs %>% 
  select(-subject)
```


#### TOA
toa and sc_toa are 0, null, or NA for all log entries - I dont think these variables are applicable for SMS   
```{r}
logs %>% 
  janitor::tabyl(toa)

logs %>% 
  janitor::tabyl(sc_toa)
```

Removing variables
```{r}
logs <- logs %>% 
  select(-c(toa, sc_toa)) %>% 
  glimpse()
```



#### Service center
The service center for the received message, null in case of sent messages.   
service_center = "The service center (SC) through which to send the message, if present."    
https://developer.android.com/reference/android/provider/Telephony.TextBasedSmsColumns#SERVICE_CENTER
```{r}
logs %>% 
  janitor::tabyl(service_center)
```

Service center should be null for outgoing messages (type 2)   
All type 2 entries are null
```{r}
logs %>% 
  filter(type == 2) %>% 
  count(service_center)
```

Not all null entries are type 2
```{r}
logs %>% 
  filter(service_center == "null") %>% 
  count(type)
```

Not much we can do with this variable and it is not consistent across log entries   
Removing variable
```{r}
logs <- logs %>% 
  select(-service_center) %>% 
  glimpse()
```



#### text content

FIX: Not seeing a lot of emojis, need to confirm they were encoded properly
```{r}
logs %>% 
  select(body) %>% 
  slice_sample(n = 50) %>% 
  print(n = Inf)
```

All group messages are NA - I think this is because group messages are MMS not SMS   
FIX: confirm they are blank in xml logs 
```{r}
logs %>% 
  filter(str_detect(address, "~")) %>% 
  select(body) %>% print(n = Inf)
```


Survey signal messages - over 20,000 survey signal messages
```{r}
logs %>% 
  filter(str_detect(body, "SurveySignal")) %>% 
  select(address, contact_name, body) %>% 
  print(n = Inf)
```

Filter out survey signal messages
```{r}
logs <- logs %>% 
  filter(!str_detect(body, "SurveySignal") | is.na(body))
```


#### date sent

Either has a date or 0. Not sure what 0 is yet, doesn't seem to be completely related to type of message and not limited to a subset of subids.
```{r}
logs %>% 
  count(date_sent == 0)

logs %>% 
  filter(date_sent != 0) %>% 
  count(type)

logs %>% 
  filter(date_sent == 0) %>% 
  count(type)
```

#### contact name
```{r}
logs %>% 
  group_by(contact_name) %>% 
  slice(1) %>% 
  select(contact_name) %>% 
  print(n = Inf)
```


<br>

### Format numbers

#### Clean standard variants of numeric numbers

Clean numbers with function
```{r}
logs$address_clean <- map(logs$address, kendra_cln_number)
logs <- logs %>% 
  mutate(address_clean = unlist(address_clean)) %>% 
  glimpse()
```

#### EDA on cleaned numbers
1 missing number - not sure what to make of this one
```{r}
logs %>% 
  filter(is.na(address)) %>% 
  kbl() %>% 
  kable_styling() %>% 
  scroll_box(width = "100%")
```

spaces, dashes, and parenthesis   
function should exclude numbers that contain alphabet characters
```{r}
logs %>% 
  filter(str_detect(logs$address, "[[:space:]-\\(\\)]")) %>% 
  select(address, address_clean) %>% 
  print(n = Inf)
```

FIX: Need to first handle multiple numbers without a ~ separating them before removing spaces
```{r}
logs %>% 
  glimpse()
```

Numbers not formatted
```{r}
logs %>% 
  filter(is.na(address_clean)) %>% 
  select(address, address_clean) %>% 
  print(n = Inf)
```

Email addresses as numbers
```{r}
logs %>% 
  filter(str_detect(address, "@")) %>% 
  count(address) %>% 
  print(n = Inf)
```

Many email addresses have unknown contact names
```{r}
logs %>% 
  filter(str_detect(address, "@")) %>% 
  count(contact_name) 
```

Other non-numeric numbers
```{r}
logs %>% 
  filter(str_detect(address, "[[:alpha:]]")) %>% 
  # filter out email addresses
  filter(!str_detect(address, "@")) %>% 
  select(address, contact_name, body) %>% 
  print(n = Inf)
```

Most of these numbers come from one subid
```{r}
logs %>% 
  filter(str_detect(address, "[[:alpha:]]")) %>% 
  # filter out email addresses
  filter(!str_detect(address, "@")) %>% 
  count(subid) %>% 
  arrange(desc(n)) %>% 
  print(n = Inf)
```

Group messages   
FIX: how to handle number?
```{r}
logs %>% 
  filter(str_detect(address, "~")) %>% 
  count(address) %>% 
  print(n = Inf)
```


<br>

### Write csv
```{r}
write_csv(logs, file.path(path_out, "meta_sms_android.csv")) %>% glimpse()
```

**Note: date saved as UTC**

<br>